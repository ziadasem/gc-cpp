# Garbage collection systems implemention in C++
## Overview

Garbage collection refers to the process of automatically reclaiming memory that is no longer in use, preventing memory leaks and ensuring efficient memory utilization. Unlike languages like Java or Python, which have built-in garbage collection, C++ provides manual control over memory management through features like dynamic memory allocation and deallocation. However, custom garbage collection systems can be implemented in C++ to facilitate memory management.

This document explains garbage collection in C++ and provides an outline for implementing a mark and sweep garbage collection in C++.

## Techniques for Garbage Collection

Several techniques can be used to implement garbage collection in C++:

### 1. Reference Counting

Reference counting involves keeping track of the number of references (or pointers) to an object. When the reference count drops to zero, the object can safely be deleted. This technique is typically implemented using smart pointers, such as std::shared_ptr and std::unique_ptr, in the C++ Standard Template Library (STL).

> Note: This repository does not implement the reference counting technique explicitly, as it is already supported through smart pointers in the STL.

**Advantages**:

* Simple to implement.
* Immediate reclamation of memory.

**Disadvantages**:

* Cannot handle circular references.


Example:
```cpp
class RefCountedObject {
    int refCount = 0;

public:
    void addRef() { ++refCount; }
    void release() {
        if (--refCount == 0) {
            delete this;
        }
    }
};
```

### 2. Tracing garbage collection

In computer programming, tracing garbage collection is a form of automatic memory management that consists of determining which objects should be deallocated ("garbage collected") by tracing which objects are reachable by a chain of references from certain "root" objects, and considering the rest as "garbage" and collecting them. Tracing is the most common type of garbage collection – so much so that "garbage collection" often refers to the tracing method, rather than others such as reference counting – and there are a large number of algorithms used in implementation. [wikipedia]

this system can be implemented by two algorithms which are:
#### 1. Mark and Sweep:

Mark-and-sweep is a two-phase garbage collection approach:
* **Mark Phase**: Traverse all accessible objects and mark them as reachable.
* **Sweep Phase**: Scan memory and deallocate objects that were not marked.

Advantages:

* Handles circular references.

Disadvantages:
* Requires traversal of all objects, which can be time-consuming.
* Needs additional memory for bookkeeping.

#### 2. Tri-color marking:
as can be conculded, mark-and-sweep doesn't exhibit the optimum performance, hence most modern tracing garbage collectors implement some variant of the **tri-color marking abstraction**, but simple collectors (such as the mark-and-sweep collector) often do not make this abstraction explicit. 

This abstraction divides objects into three sets:
* **White Set**: Objects that are candidates for garbage collection.
* **Gray Set**: Objects that are reachable but whose children have not been fully explored.
* **Black Set**: Objects that are reachable and whose children have been fully explored.

**Advantages**:

* Can be performed "on-the-fly" without halting the system for significant periods.
* Improves efficiency compared to simpler methods like mark-and-sweep.

**Disadvantages**:

* More complex to implement.
* Requires careful handling of concurrency and object state.

> Note: Simple collectors like mark-and-sweep often do not explicitly implement the tri-color abstraction.


## What is in This Repository and How to Contribute
This repository implements a tracing garbage collector system in C++. Each implementation resides in its own directory, along with its respective documentation (a video explanation can also be created). While the current implementation provides a foundation for understanding garbage collection, there are still some gaps (or "cavities") in the functionality, which are explicitly declared in its corresponding documentation.

Contribution Guidelines:

1. **Improve the Implementation**: Address existing gaps and refine the garbage collector to make it more robust and efficient.

2. **Add Test Cases**: Create additional test cases to ensure the garbage collector works as expected in various scenarios.

We welcome all contributions to this repository and encourage developers to share their improvements!

>Note: This documentation is primarily generated by AI and fine-tuned prompts.